老早之前，大概两年以前，写了好多内核驱动代码。那个时候并没有深入学习内核内部。现在再重新学习内核代码，难免要做些实验。

做实验第一步就是要能够进入内核中，linux提供了module机制，能够动态的加载内核模块。昨天搞了一天，结果被一个小问题给绕住了，今天早上起来解决之。

参考的主要内容就是
The Linux Kernel Module Programming Guide
http://www.tldp.org/LDP/lkmpg/2.6/lkmpg.pdf

首先拿来书先搞个hello world吧，一步一步的搞。

可是make的时候怎么也不过，原来犯了一个低级错误，直接拷贝粘帖啊……“make -C”本应改是半角的，结果那个减号搞成全角的了，太坑爹了。

闲话少说直接上代码：
hello.c

    #include <linux/module.h>
    #include <linux/kernel.h>

    int hello_init(void)
    {
        printk(KERN_INFO "Hello kernel module.\n");
        return 0;
    }
    void hello_exit(void)
    {
        printk(KERN_INFO "Goodbye kernel module.\n");
    }


    module_init(hello_init);
    module_exit(hello_exit);

Makefile:

    obj-m += hello.o
    KERNEL_VERSION = /lib/modules/$(shell uname -r)/build/

    all:
    make -C $(KERNEL_VERSION) M=$(PWD) modules
    clean:
    make -C $(KERNEL_VERSION) M=$(PWD) clean

执行make

    CC [M] /home/imay/blog/hello_module/hello.o
    Building modules, stage 2.
    MODPOST 1 modules
    CC /home/imay/blog/hello_module/hello.mod.o
    LD [M] /home/imay/blog/hello_module/hello.ko
    make[1]: Leaving directory `/usr/src/linux-headers-3.0.0-12-generic'

然后执行

    sudo insmod hello.ko

此时模块已经插入内核中，使用lsmod命令来找到自己的module

    lsmod | grep hello

结果如下所示：

    hello 12421 0

这样自己编写的模块就在内核中了。

然后之前在程序中打印的那条log，可以使用dmesg命令找到

    dmesg | tail -1

应该显示的结果如下

    [ 5531.946244] Hello kernel module

好了，是时候吧module从kernel中拿出来了，使用rmmod命令

    sudo rmmod hello

OK，再看看退出时的那条日志有没有好，同样执行

    dmesg | tail -1

看到了如下就说明模块按照自己的设计来走了

    [ 5874.821994] Goodbye kernel module.


到这里，一个简单的内核模块就这样在内核中走了一圈。

另外除了dmesg命令之外，也可以在/var/log/kern.log中观察kernel的日志。这个还是不错的，dmesg只能看这次启动的，这里能够找到历史运行的所有日志，有的历史日志已经被达成了压缩包节省空间资源。
