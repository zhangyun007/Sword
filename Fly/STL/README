STL分序列式容器和辅助容器，前者是呈线性结构；后者包括hash表和各种树形结构。

单向链表中所包含数据的长度，我们可以对应于树形容器的深度。同样数量的数据，存在树结构中显然要比存在链表中的深度要小，对树搜索的最坏情况要比链表好，但是建树比建链表需要更多的时间。



谷歌开源团队近日发布了C++ B-Tree，这是一个C++模板库，实现了基于B-tree数据结构的有序内存容器。类似于STL的map、set、multimap和multiset模板，C++ B-tree也提供了btree_map、btree_set、btree_multimap和btree_multiset等模板。 


B-tree（多路搜索树，并不是二叉的）是一种常见的数据结构。使用B-tree结构可以显著减少定位记录时所经历的中间过程，从而加快存取速度。这个数据结构一般用于数据库的索引，综合效率较高。 


由于B-trees可以保持磁盘寻道到最低限度，通常作为二次存储数据结构。对于内存中数据结构来说，将缓存未命中率保持在最低限度，可以产生更高的性能。C++ B-tree在搜索树时，通过在每个节点执行多个键比较，更好地利用了缓存。缓存行为的改善，可以使访问大型容器时的性能有显著提升。 

谷歌开源团队同时也表示，C++ B-tree容器也不是没有缺点，与标准STL容器不同的是，修改C++ B-tree容器，会令所有未在该容器中的迭代器失效。出于这个原因，谷歌在该库中还增加了一个“安全”容器版本，安全容器中的迭代器会保存当前key的副本，并会在使用迭代器时自动复位。 


项目地址：https://code.google.com/p/cpp-btree/

https://github.com/CalebLBaker/b-tree/blob/master/bTree.cpp